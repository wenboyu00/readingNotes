# Python 工匠

 从工程实践的角度讲如何写好Python代码，同时也解释了背后的原理和机制。

# 变量

变量名称

- 更准确，适用范围更窄

- 尽量短，简单词

- 要类型匹配

- 减少变量名相似性

- 保持变量名前后一致性

- 使用时再创建

- 同一作用于不要太多变量，要提炼和拆分

添加变量注释类型

# 注释

代码之外的说明文字，描述代码做了什么，为什么这么做。

接口注释：着重描写功能和参数

先写注释，再写代码

# 容器类型

在进行函数调用时，传递变量所指对象的引用

对于可变类型，必要时对其进行拷贝操作，能避免产生意料之外的影响，使用深拷贝copy.deepcopy()

Python 3.7前，字典类型是无序的，之后变为保留数据的插入顺序

- OrderedDict是有序字典

哈希的对象才能存入集合，或者作为字典的键使用

- 自定义类实现____hash____和____eq____

列表推导式可以更快速地完成遍历、过滤、处理以及构建新列表操作

- 不要编写过于复杂的推导式，用朴实的代码替代就好·
- 不要把推导式当作代码量更少的循环，写普通循环就好

不要在遍历列表的同时修改列表数量，否则会出现不可预期的结果

- 这里修改指，删除或增加列表数量

# 布尔

## 内置类型布尔值

| 布尔值状态 | 内置类型                                                    |
| ---------- | ----------------------------------------------------------- |
| False      | None、0、False、[]、()、{}、set()、frozenset()              |
| True       | 非0的数值、True，非空的序列、元组、字典，用户定义的类和实例 |
| 判断情况   | is：判断某个对象是否为None, True, False时  ==： 其他情况    |

## 布尔判断

不要显式地和布尔值做比较，例如：flag == True

利用类型本身的布尔值规则，省略零值判断，例如：flag

把not代表的否定逻辑移入表达式内部

仅在需要判断某个对象是否是None、True、False时，使用is运算符

and的优先级比or高，不要忘记使用括号来让逻辑更清晰

在使用or运算符替代条件分支时，请注意避开因布尔值运算导致的陷阱

## 布尔判断魔法方法

定义\__len\__和\__bool\__魔法方法，可以自定义对象的布尔值规则

定义eq方法，可以修改对象在进行 == 运算时的行为

# 异常处理

返回错误信息，更地道的做法是抛出自定义异常。

除了try语句外，with语句也经常用来处理异常，自定义上下文管理器可以有效复用异常处理逻辑。

在捕获异常时，过于模糊是不可取的，精确的异常捕获有助于我们写出更健壮的代码。

- 一个try语句支持多个except子句，把更精确的异常类放在前面。

## 上下文管理器

- 上下文管理器经常用来处理异常，它最常见的用途是替代finally子句
- 上下文管理器可以用来忽略某段代码里的异常
- 使用@contextmanager装饰器可以轻松定义上下文管理器

## 当你抛出异常的时候

- 保证模块内抛出的异常与模块自身的抽象级别一致
- 如果异常的抽象级别过高，把它替换为更低级的新异常
- 如果异常的抽象级别过低，把它包装成更高级的异常，然后重新抛出
- 不要让调用方用字符串匹配来判断异常种类，尽量提供可区分的异常

# 迭代器

iter()函数会尝试获取一个迭代器对象

next()函数会获取迭代器的下一个内容

自定义迭代器需要实现

- __iter__(), 初始值
- __next__(), 迭代内容

生成器对象是迭代器的一种

可迭代对象不一定是迭代器，但迭代器一定是可迭代对象

对可迭代对象使用iter()会返回迭代器，迭代器则会返回它自身

可迭代对象只需要实现__iter__方法，而迭代器要额外实现__next__方法

# 函数

不要使用可变类型作为参数默认值，用None来代替

使用标记对象，可以严格区分函数调用时是否提供了某个参数

定义仅限关键字参数，可以强制要求调用方提供参数名，提升可读性

函数应该拥有稳定的返回类型，不要返回多种类

适合返回None的情况——操作类函数、查询类函数表示意料之中的缺失

在执行失败时，相比返回None，抛出异常更为合适

如果提前返回结果可以提升可读性，就提前返回，不必追求“单一出口”

函数超过65行算是一个危险信号

抽象与分层思想可以帮我们更好地构建与管理复杂的系统

同一个函数内的代码应该处在同一抽象级别

# 装饰器

functools.wraps() 解决装饰器原始函数的过程中，会产生“元数据丢失”副作用

用类实现的装饰器分为两种：“函数替换”与“实例替换”。

- 实例替换，

- - 有效地实现状态管理、追加行为功能。
  - 有参数“实例替换”装饰器时，你需要定义一个额外的函数来配合装饰器类

装饰器是利用闭包原理通过多层嵌套函数实现

利用仅限关键字参数，可以很方便地实现可选参数的装饰器

# 面向对象编程

类与实例的数据，都保存在一个名为__dict__的字典属性中

- 灵活利用__dict__属性，能帮你做到常规做法难以完成的一些事情

@classmethod 定义类方法，类方法常用作工厂方法

@staticmethod 定义静态方法，静态方法不依赖实例状态，是一种无状态方法 

@property 定义动态属性对象，该属性对象的获取、设置和删除行为都支持自定义

super()函数获取的并不是当前类的父类，而是当前MRO链条里的下一个类

 

“鸭子类型”是Python特点之一，一般不做任何严格的类型检查

虽然“鸭子类型”非常实用，有两个缺点

- 缺乏标准
- 过于隐式

 

继承提供了相当强大的代码复用机制，但同时也带来了非常紧密的耦合关系

错误使用继承容易导致代码失控

**对事物的行为建模**，而不是事物本身建模，更容易孵化出好的面向对象设计

在创建继承关系时应当谨慎。**用组合来替代继承有时是更好的做法**

 

多态是面向对象编程里的基本概念，同时也是最强大的思维工具之一

**多态可能的介入时机**：许多类似的条件分支判断、许多针对类型的isinstance()判断

## 面向对象设计原则

| 原则名称          | 内容                                                         |
| ----------------- | ------------------------------------------------------------ |
| SRP  单一责任原则 | **一个类只应该有一种被修改的原因，每个类都应该只承担一种职责**  编写**更小的类**通常更不容易违反SRP  SRP同样适用于函数，你可以让函数和类协同工作 |
| OCP  开闭原则     | **类应该对修改关闭，对扩展开放**     **不修改某个类的前提下，扩展它的行为**    通过分析需求，找到代码中易变的部分，是让类符合OCP的关键     使用子类继承的方式可以让类符合OCP   通过算法类与依赖注入，也可以让类符合OCP   将数据与逻辑分离，使用数据驱动的方式也是实践OCP的好办法    实现方法：  子类继承  组合与依赖注入  数据驱动 |
| LSP  里式替换     | 所有子类（派生类）对象应该可以任意替代父类（基类）对象使用，且不会破坏程序  原本的功能。  实现方法：     子类不应该抛出父类不认识的异常，子类异常要遵循父类异常的规范   子类方法参数和父类一致，但子类更抽象，       子类新增参数是可选      子类返回值和父类一只，或者返回父类结果都子类对象    父类是闭的部分，子类是开的部分 |
| DIP  依赖倒置     | 高层模块不应该依赖底层模块，二者应该**依赖抽象**  退后一步是“鸭子”  向前一步是“协议”  抽象一定好吗  优点：抽象让代码变得更灵活，它解耦了模块间的依赖关系。  缺点：带来了额外的编码与理解成本  思考结果：只有对代码中那些容易变化的东西进行抽象，才能获得最大的收益。 |
| ISP接口隔离       | ISP认为客户依赖的接口不应该包含任何它不需要的方法  设计接口就是设计抽象  写更小的类、更小的接口在大多数情况下是个好主意 |